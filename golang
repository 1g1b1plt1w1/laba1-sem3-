package main

import (
 "bufio"
 "fmt"
 "os"
 "strconv"
 "strings"
)

// ======================== ENUM КОМАНД ========================

type Command int

const (
 PRINT Command = iota

 MCREATE
 MPUSH
 MPUSHIDX
 MGETIDX
 MDELIDX
 MSETIDX
 MLENGTH
 MREAD

 FPUSH
 FPUSHTAIL
 FPUSHBEFORE
 FPUSHAFTER
 FPOP
 FPOPTAIL
 FPOPBEFORE
 FPOPAFTER
 FDELVAL
 FFINDVAL
 FREADHT
 FREADTH

 LPUSHHEAD
 LPUSHTAIL
 LPUSHBEFORE
 LPUSHAFTER
 LPOPHEAD
 LPOPTAIL
 LPOPBEFORE
 LPOPAFTER
 LDELVAL
 LFINDVAL
 LREADHT
 LREADTH

 SPUSH
 SPOP
 SREAD

 QPUSH
 QPOP
 QREAD

 TINSERT
 TFIND
 TDELETE
 TREAD
 TCHECKAVL
)

var commandMap = map[string]Command{
 "PRINT": PRINT,

 "MCREATE":  MCREATE,
 "MPUSH":    MPUSH,
 "MPUSHIDX": MPUSHIDX,
 "MGETIDX":  MGETIDX,
 "MDELIDX":  MDELIDX,
 "MSETIDX":  MSETIDX,
 "MLENGTH":  MLENGTH,
 "MREAD":    MREAD,

 "FPUSH":       FPUSH,
 "FPUSHTAIL":   FPUSHTAIL,
 "FPUSHBEFORE": FPUSHBEFORE,
 "FPUSHAFTER":  FPUSHAFTER,
 "FPOP":        FPOP,
 "FPOPTAIL":    FPOPTAIL,
 "FDELVAL":     FDELVAL,
 "FREADHT":     FREADHT,
 "FREADTH":     FREADTH,

 "LPUSHHEAD":   LPUSHHEAD,
 "LPUSHTAIL":   LPUSHTAIL,
 "LPUSHBEFORE": LPUSHBEFORE,
 "LPUSHAFTER":  LPUSHAFTER,
 "LPOPHEAD":    LPOPHEAD,
 "LPOPTAIL":    LPOPTAIL,
 "LDELVAL":     LDELVAL,
 "LFINDVAL":    LFINDVAL,
 "LREADHT":     LREADHT,
 "LREADTH":     LREADTH,

 "SPUSH": SPUSH,
 "SPOP":  SPOP,
 "SREAD": SREAD,

 "QPUSH": QPUSH,
 "QPOP":  QPOP,
 "QREAD": QREAD,

 "TINSERT":   TINSERT,
 "TDELETE":   TDELETE,
 "TREAD":     TREAD,
 "TCHECKAVL": TCHECKAVL,
}

// ======================== ARRAY ========================

type Array struct {
 data []string
}

func NewArray(capacity int) Array {
 return Array{data: make([]string, 0, capacity)}
}

func (a *Array) PushBack(v string) { a.data = append(a.data, v) }
func (a *Array) Insert(idx int, v string) {
 if idx < 0 || idx > len(a.data) {
  return
 }
 a.data = append(a.data, "")
 copy(a.data[idx+1:], a.data[idx:])
 a.data[idx] = v
}
func (a *Array) Get(idx int) string {
 if idx < 0 || idx >= len(a.data) {
  return ""
 }
 return a.data[idx]
}
func (a *Array) Set(idx int, v string) {
 if idx < 0 || idx >= len(a.data) {
  return
 }
 a.data[idx] = v
}
func (a *Array) Erase(idx int) {
 if idx < 0 || idx >= len(a.data) {
  return
 }
 copy(a.data[idx:], a.data[idx+1:])
 a.data = a.data[:len(a.data)-1]
}
func (a *Array) Length() int { return len(a.data) }
func (a *Array) Read() string {
 return " " + strings.Join(a.data, " ") + " "
}

// ======================== ONE-LINKED LIST ========================

type OneNode struct {
 Data string
 Next *OneNode
}

type OneLinkedList struct {
 Head *OneNode
 Tail *OneNode
}

func NewOneLinkedList() OneLinkedList { return OneLinkedList{} }

func (l *OneLinkedList) PushBack(v string) {
 n := &OneNode{Data: v}
 if l.Head == nil {
  l.Head = n
  l.Tail = n
  return
 }
 l.Tail.Next = n
 l.Tail = n
}
func (l *OneLinkedList) PopFront() {
 if l.Head == nil {
  return
 }
 l.Head = l.Head.Next
 if l.Head == nil {
  l.Tail = nil
 }
}
func (l *OneLinkedList) PopBack() {
 if l.Head == nil {
  return
 }
 if l.Head == l.Tail {
  l.Head = nil
  l.Tail = nil
  return
 }
 cur := l.Head
 for cur.Next != l.Tail {
  cur = cur.Next
 }
 cur.Next = nil
 l.Tail = cur
}
func (l *OneLinkedList) DelByValue(val string) {
 if l.Head == nil {
  return
 }
 for l.Head != nil && l.Head.Data == val {
  l.Head = l.Head.Next
 }
 if l.Head == nil {
  l.Tail = nil
  return
 }
 prev := l.Head
 cur := l.Head.Next
 for cur != nil {
  if cur.Data == val {
   prev.Next = cur.Next
   if cur == l.Tail {
    l.Tail = prev
   }
   cur = prev.Next
  } else {
   prev = cur
   cur = cur.Next
  }
 }
}
func (l *OneLinkedList) ReadHT() string {
 var b []string
 for cur := l.Head; cur != nil; cur = cur.Next {
  b = append(b, cur.Data)
 }
 return " " + strings.Join(b, " ") + " "
}
func (l *OneLinkedList) ReadTH() string { return l.ReadHT() }

// ======================== LINKED LIST ========================

type DNode struct {
 Data string
 Prev *DNode
 Next *DNode
}

type LinkedList struct {
 Head *DNode
 Tail *DNode
}
func NewLinkedList() LinkedList { return LinkedList{} }

func (l *LinkedList) PushFront(v string) {
 n := &DNode{Data: v, Next: l.Head}
 if l.Head != nil {
  l.Head.Prev = n
 } else {
  l.Tail = n
 }
 l.Head = n
}
func (l *LinkedList) PushBack(v string) {
 n := &DNode{Data: v, Prev: l.Tail}
 if l.Tail != nil {
  l.Tail.Next = n
 } else {
  l.Head = n
 }
 l.Tail = n
}
func (l *LinkedList) PopFront() {
 if l.Head == nil {
  return
 }
 if l.Head == l.Tail {
  l.Head = nil
  l.Tail = nil
  return
 }
 l.Head = l.Head.Next
 l.Head.Prev = nil
}
func (l *LinkedList) PopBack() {
 if l.Tail == nil {
  return
 }
 if l.Head == l.Tail {
  l.Head = nil
  l.Tail = nil
  return
 }
 l.Tail = l.Tail.Prev
 l.Tail.Next = nil
}
func (l *LinkedList) DelByValue(val string) {
 cur := l.Head
 for cur != nil {
  if cur.Data == val {
   if cur == l.Head {
    l.PopFront()
   } else if cur == l.Tail {
    l.PopBack()
   } else {
    cur.Prev.Next = cur.Next
    cur.Next.Prev = cur.Prev
   }
   return
  }
  cur = cur.Next
 }
}
func (l *LinkedList) ReadHT() string {
 var out []string
 for cur := l.Head; cur != nil; cur = cur.Next {
  out = append(out, cur.Data)
 }
 return " " + strings.Join(out, " ") + " "
}
func (l *LinkedList) ReadTH() string {
 var out []string
 for cur := l.Tail; cur != nil; cur = cur.Prev {
  out = append(out, cur.Data)
 }
 return " " + strings.Join(out, " ") + " "
}

// ======================== STACK ========================

type Stack struct{ data []string }

func NewStack() Stack                      { return Stack{data: []string{}} }
func (s *Stack) Push(v string)             { s.data = append(s.data, v) }
func (s *Stack) Pop()                      { if len(s.data) > 0 { s.data = s.data[:len(s.data)-1] } }
func (s *Stack) Read() string              { return " " + strings.Join(s.data, " ") + " " }

// ======================== QUEUE ========================

type Queue struct{ data []string }

func NewQueue() Queue                      { return Queue{data: []string{}} }
func (q *Queue) Push(v string)             { q.data = append(q.data, v) }
func (q *Queue) Pop()                      { if len(q.data) > 0 { q.data = q.data[1:] } }
func (q *Queue) Read() string              { return " " + strings.Join(q.data, " ") + " " }

// ======================== AVL TREE ========================

type TreeNode struct {
 Data   int
 Left   *TreeNode
 Right  *TreeNode
 Height int
}
type Tree struct{ Root *TreeNode }

func height(n *TreeNode) int { if n == nil { return 0 }; return n.Height }
func fixHeight(n *TreeNode)  { hL, hR := height(n.Left), height(n.Right); if hL > hR { n.Height = hL + 1 } else { n.Height = hR + 1 } }
func balanceFactor(n *TreeNode) int { return height(n.Right) - height(n.Left) }
func rotateRight(p *TreeNode) *TreeNode { q := p.Left; p.Left = q.Right; q.Right = p; fixHeight(p); fixHeight(q); return q }
func rotateLeft(q *TreeNode) *TreeNode  { p := q.Right; q.Right = p.Left; p.Left = q; fixHeight(q); fixHeight(p); return p }
func balance(n *TreeNode) *TreeNode {
 fixHeight(n)
 if balanceFactor(n) == 2 {
  if balanceFactor(n.Right) < 0 {
   n.Right = rotateRight(n.Right)
  }
  return rotateLeft(n)
 }
 if balanceFactor(n) == -2 {
  if balanceFactor(n.Left) > 0 {
   n.Left = rotateLeft(n.Left)
  }
  return rotateRight(n)
 }
 return n
}
func insertNode(n *TreeNode, x int) *TreeNode {
 if n == nil {
  return &TreeNode{Data: x, Height: 1}
 }
 if x < n.Data {
  n.Left = insertNode(n.Left, x)
 } else if x > n.Data {
  n.Right = insertNode(n.Right, x)
 }
 return balance(n)
}
func (t *Tree) Insert(x int) { t.Root = insertNode(t.Root, x) }
func inorder(n *TreeNode, acc *[]string) {
 if n == nil {
  return
 }
 inorder(n.Left, acc)
 *acc = append(*acc, strconv.Itoa(n.Data))
 inorder(n.Right, acc)
}
func (t *Tree) Read() string {
 var out []string
 inorder(t.Root, &out)
 return " " + strings.Join(out, " ") + " "
}

// ======================== ГЛАВНЫЙ КОД ========================
var (
 arrays   = map[string]*Array{}
 onelists = map[string]*OneLinkedList{}
 llists   = map[string]*LinkedList{}
 stacks   = map[string]*Stack{}
 queues   = map[string]*Queue{}
 trees    = map[string]*Tree{}
)

func writeState(filename string) error {
 f, err := os.Create(filename)
 if err != nil {
  return err
 }
 defer f.Close()
 w := bufio.NewWriter(f)
 for name, a := range arrays {
  fmt.Fprintf(w, "Array %s%s\n", name, a.Read())
 }
 for name, l := range onelists {
  fmt.Fprintf(w, "OneLinkedList %s%s\n", name, l.ReadHT())
 }
 for name, l := range llists {
  fmt.Fprintf(w, "LinkedList %s%s\n", name, l.ReadHT())
 }
 for name, q := range queues {
  fmt.Fprintf(w, "Queue %s%s\n", name, q.Read())
 }
 for name, s := range stacks {
  fmt.Fprintf(w, "Stack %s%s\n", name, s.Read())
 }
 for name, t := range trees {
  fmt.Fprintf(w, "Tree %s%s\n", name, t.Read())
 }
 fmt.Fprintln(w)
 return w.Flush()
}

func readState(filename string) {
 f, err := os.Open(filename)
 if err != nil {
  return
 }
 defer f.Close()
 sc := bufio.NewScanner(f)
 for sc.Scan() {
  parts := strings.Fields(sc.Text())
  if len(parts) < 2 {
   continue
  }
  kind, name := parts[0], parts[1]
  vals := parts[2:]
  switch kind {
  case "Array":
   a := NewArray(10)
   for _, v := range vals {
    a.PushBack(v)
   }
   arrays[name] = &a
  case "OneLinkedList":
   l := NewOneLinkedList()
   for _, v := range vals {
    l.PushBack(v)
   }
   onelists[name] = &l
  case "LinkedList":
   l := NewLinkedList()
   for _, v := range vals {
    l.PushBack(v)
   }
   llists[name] = &l
  case "Queue":
   q := NewQueue()
   for _, v := range vals {
    q.Push(v)
   }
   queues[name] = &q
  case "Stack":
   s := NewStack()
   for _, v := range vals {
    s.Push(v)
   }
   stacks[name] = &s
  case "Tree":
   t := &Tree{}
   for _, v := range vals {
    n, _ := strconv.Atoi(v)
    t.Insert(n)
   }
   trees[name] = t
  }
 }
}

func doCommand(name string, data []string, cmd Command) {
 switch cmd {
 case MCREATE:
  a := NewArray(10)
  arrays[name] = &a
 case MPUSH:
  if a, ok := arrays[name]; ok {
   for _, v := range data {
    a.PushBack(v)
   }
  }
 case MREAD:
  if a, ok := arrays[name]; ok {
   fmt.Println(a.Read())
  }
 case FPUSH:
  if l, ok := onelists[name]; ok {
   for _, v := range data {
    l.PushBack(v)
   }
  }
 case FREADHT:
  if l, ok := onelists[name]; ok {
   fmt.Println(l.ReadHT())
  }
 case LPUSHTAIL:
  if l, ok := llists[name]; ok {
   for _, v := range data {
    l.PushBack(v)
   }
  }
 case LREADHT:
  if l, ok := llists[name]; ok {
   fmt.Println(l.ReadHT())
  }
 case SPUSH:
  if s, ok := stacks[name]; ok {
   for _, v := range data {
    s.Push(v)
   }
  }
 case SREAD:
  if s, ok := stacks[name]; ok {
   fmt.Println(s.Read())
  }
 case QPUSH:
  if q, ok := queues[name]; ok {
   for _, v := range data {
    q.Push(v)
   }
  }
 case QREAD:
  if q, ok := queues[name]; ok {
   fmt.Println(q.Read())
  }
 case TINSERT:
  if t, ok := trees[name]; ok {
   for _, v := range data {
    n, _ := strconv.Atoi(v)
    t.Insert(n)
   }
  } else {
   tr := &Tree{}
   for _, v := range data {
    n, _ := strconv.Atoi(v)
    tr.Insert(n)
   }
   trees[name] = tr
  }
 case TREAD:
  if t, ok := trees[name]; ok {
   fmt.Println(t.Read())
  }
 case PRINT:
  fmt.Println("=== PRINT ===")
  if a, ok := arrays[name]; ok {
   fmt.Println("Array", name, a.Read())
   return
  }
  if l, ok := onelists[name]; ok {
   fmt.Println("OneLinkedList", name, l.ReadHT())
   return
  }
  if l, ok := llists[name]; ok {
   fmt.Println("LinkedList", name, l.ReadHT())
   return
  }
  if s, ok := stacks[name]; ok {
   fmt.Println("Stack", name, s.Read())
   return
  }
  if q, ok := queues[name]; ok {
   fmt.Println("Queue", name, q.Read())
   return
  }
  if t, ok := trees[name]; ok {
   fmt.Println("Tree", name, t.Read())
   return
  }
  fmt.Println("Объект", name, "не найден.")
 }
}
func main() {
 if len(os.Args) != 5 {
  fmt.Println("Usage: --file <filename> --query \"COMMAND name args...\"")
  return
 }
 var file, query string
 if os.Args[1] == "--file" {
  file = os.Args[2]
 }
 if os.Args[3] == "--query" {
  query = os.Args[4]
 }

 readState(file)
 parts := strings.Fields(query)
 if len(parts) < 2 {
  fmt.Println("Bad query")
  return
 }
 cmdStr, name := parts[0], parts[1]
 data := parts[2:]
 cmd, ok := commandMap[cmdStr]
 if !ok {
  fmt.Println("Unknown command:", cmdStr)
  return
 }
 doCommand(name, data, cmd)
 writeState(file)
}
